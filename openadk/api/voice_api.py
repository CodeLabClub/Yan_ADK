# coding: utf-8

"""
    Yanshee RESTful API

     ## Overview Yanshee RESTful APIs are generated by the [swagger-codegen](https://github.com/swagger-api/swagger-codegen) project. By using the [OpenAPI-Spec](https://github.com/swagger-api/swagger-core/wiki) from a remote server. The API service uses the [Connexion](https://github.com/zalando/connexion) library on top of Flask.  To provide the API service, Yanshee RESTful APIs are integrated into apollo package, it is a part of Yanshee-ROS framework. Yanshee RESTful APIs provided two language versions: - [English version](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_en/1.0.0) - [Chinese version](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_cn/1.0.0)  ## Requirements. Python 2.7 or 3.4+  ## Getting Started Please follow the [installation procedure](#installation--usage) and then run the following:  ``` from __future__ import print_function import time import openadk from openadk.rest import ApiException from pprint import pprint  # create an instance of the API class configuration = openadk.Configuration() configuration.host = 'http://192.168.1.100:9090/v1' api_instance = openadk.DevicesApi(openadk.ApiClient(configuration)) try:  # Get system's battery information  api_response = api_instance.get_devices_battery()  pprint(api_response) except ApiException as e:  print(\"Exception when calling DevicesApi->get_devices_battery: %s\" % e)  ```   # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: swenggroup@ubtrobot.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openadk.api_client import ApiClient


class VoiceApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_voice_asr(self, **kwargs):  # noqa: E501
        """Stop automatic speech recognition  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_voice_asr(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_voice_asr_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_voice_asr_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_voice_asr_with_http_info(self, **kwargs):  # noqa: E501
        """Stop automatic speech recognition  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_voice_asr_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_voice_asr" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/asr', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_voice_iat(self, **kwargs):  # noqa: E501
        """Stop auto transform  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_voice_iat(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_voice_iat_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_voice_iat_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_voice_iat_with_http_info(self, **kwargs):  # noqa: E501
        """Stop auto transform  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_voice_iat_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_voice_iat" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/iat', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_voice_offline_syntax(self, body, **kwargs):  # noqa: E501
        """Delete a offline grammar based offline grammar's name  # noqa: E501

        Default offline grammar cannot be added, deleted or modified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_voice_offline_syntax(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceDeleteOfflineSyntax body:  (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_voice_offline_syntax_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_voice_offline_syntax_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def delete_voice_offline_syntax_with_http_info(self, body, **kwargs):  # noqa: E501
        """Delete a offline grammar based offline grammar's name  # noqa: E501

        Default offline grammar cannot be added, deleted or modified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_voice_offline_syntax_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceDeleteOfflineSyntax body:  (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_voice_offline_syntax" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `delete_voice_offline_syntax`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/asr/offlinesyntax', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_voice_tts(self, **kwargs):  # noqa: E501
        """Stop all text to speech  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_voice_tts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_voice_tts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_voice_tts_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_voice_tts_with_http_info(self, **kwargs):  # noqa: E501
        """Stop all text to speech  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_voice_tts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_voice_tts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/tts', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_voice_asr(self, **kwargs):  # noqa: E501
        """Get automatic speech recognition working status  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_asr(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: VoiceGetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_voice_asr_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_voice_asr_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_voice_asr_with_http_info(self, **kwargs):  # noqa: E501
        """Get automatic speech recognition working status  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_asr_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: VoiceGetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_voice_asr" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/asr', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VoiceGetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_voice_iat(self, **kwargs):  # noqa: E501
        """Get auto transform(iat) result  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_iat(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: VoiceGetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_voice_iat_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_voice_iat_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_voice_iat_with_http_info(self, **kwargs):  # noqa: E501
        """Get auto transform(iat) result  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_iat_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: VoiceGetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_voice_iat" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/iat', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VoiceGetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_voice_offline_syntax(self, body, **kwargs):  # noqa: E501
        """Get offline grammar configuration  # noqa: E501

         Get all offline grammars' details. Please note, the default offline grammar's name is \"default\". Default offline grammar cannot be added, deleted or modified. The current offline speech recognition can support Chinese and English. But the English support is an experimental feature. All the field name and value should be written as <html><font color=\"red\">uppercase camel case format</font></html>. ``` {  \"grammar\": \"LocalCmd\",  \"slot\": [   {    \"name\": \"Pre\"   },   {    \"name\": \"Commands\"   }  ],  \"start\": \"LocalCmdStart\",  \"startinfo\": \"[<Pre>]<Commands>\",  \"rule\": [   {    \"name\": \"Pre\",    \"value\": \"IWantYou|Please|Start\"   },   {    \"name\": \"Commands\",    \"value\": \"Dancing\"   }  ] } ```  Please be very careful when you configure offline grammar. If the configuration is not matched the restrictions. Speech recognition may not work. The restrictions as below: - All grammar value cannot be duplicated; - All slot field cannot be duplicated; - All rule field cannot be NULL. Every rule name and value should be unique. Please pay special attention that <html><strong><font color=\"blue\">VOID</font></strong></html>, <html><strong><font color=\"blue\">NULL</font></strong></html> and <html><strong><font color=\"blue\">GARBAGE</font></strong></html> are reserved as key words. Please do not use them. - In rule field, the user can use key words !id to define the semantic. The semantic only support numbers, please do not use other character. The supported semantic number is 32 bits signed integer. The range is <html>[-2<sup>(32-1)</sup>, 2<sup>(32-1)</sup> -1]</html>.  The grammar specification and built-in keywords:  | Operator | description | example | |---|---|---| |!| the next field is a keywords | !grammar| |<>| define a rule name | &lt;name&gt;| |;| terminator | end of a line | | &Iota; | Or, define a side-by-side structure | 张三&Iota;李四 | |[]| optional, indicating that the content can be said | &lt;call&gt;: [找] &lt;name&gt;| |:| define a rule | &lt;name&gt;:张三&Iota;李四| |()| encapsulation operation, defining implicit rules |&lt;call&gt;:找(张三&Iota;李四)| |/* */| block comment |/* comment content */| |//| line comment | // comment content | More details： https://doc.xfyun.cn/msc_windows/%E8%AF%AD%E6%B3%95%EF%BC%88%E5%91%BD%E4%BB%A4%E8%AF%8D%EF%BC%89%E8%AF%86%E5%88%AB.html   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_offline_syntax(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: Offline grammar's name (required)
        :return: VoiceGetOfflineSyntaxResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_voice_offline_syntax_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_voice_offline_syntax_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def get_voice_offline_syntax_with_http_info(self, body, **kwargs):  # noqa: E501
        """Get offline grammar configuration  # noqa: E501

         Get all offline grammars' details. Please note, the default offline grammar's name is \"default\". Default offline grammar cannot be added, deleted or modified. The current offline speech recognition can support Chinese and English. But the English support is an experimental feature. All the field name and value should be written as <html><font color=\"red\">uppercase camel case format</font></html>. ``` {  \"grammar\": \"LocalCmd\",  \"slot\": [   {    \"name\": \"Pre\"   },   {    \"name\": \"Commands\"   }  ],  \"start\": \"LocalCmdStart\",  \"startinfo\": \"[<Pre>]<Commands>\",  \"rule\": [   {    \"name\": \"Pre\",    \"value\": \"IWantYou|Please|Start\"   },   {    \"name\": \"Commands\",    \"value\": \"Dancing\"   }  ] } ```  Please be very careful when you configure offline grammar. If the configuration is not matched the restrictions. Speech recognition may not work. The restrictions as below: - All grammar value cannot be duplicated; - All slot field cannot be duplicated; - All rule field cannot be NULL. Every rule name and value should be unique. Please pay special attention that <html><strong><font color=\"blue\">VOID</font></strong></html>, <html><strong><font color=\"blue\">NULL</font></strong></html> and <html><strong><font color=\"blue\">GARBAGE</font></strong></html> are reserved as key words. Please do not use them. - In rule field, the user can use key words !id to define the semantic. The semantic only support numbers, please do not use other character. The supported semantic number is 32 bits signed integer. The range is <html>[-2<sup>(32-1)</sup>, 2<sup>(32-1)</sup> -1]</html>.  The grammar specification and built-in keywords:  | Operator | description | example | |---|---|---| |!| the next field is a keywords | !grammar| |<>| define a rule name | &lt;name&gt;| |;| terminator | end of a line | | &Iota; | Or, define a side-by-side structure | 张三&Iota;李四 | |[]| optional, indicating that the content can be said | &lt;call&gt;: [找] &lt;name&gt;| |:| define a rule | &lt;name&gt;:张三&Iota;李四| |()| encapsulation operation, defining implicit rules |&lt;call&gt;:找(张三&Iota;李四)| |/* */| block comment |/* comment content */| |//| line comment | // comment content | More details： https://doc.xfyun.cn/msc_windows/%E8%AF%AD%E6%B3%95%EF%BC%88%E5%91%BD%E4%BB%A4%E8%AF%8D%EF%BC%89%E8%AF%86%E5%88%AB.html   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_offline_syntax_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: Offline grammar's name (required)
        :return: VoiceGetOfflineSyntaxResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_voice_offline_syntax" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_voice_offline_syntax`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'body' in params:
            query_params.append(('body', params['body']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/asr/offlinesyntax', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VoiceGetOfflineSyntaxResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_voice_offline_syntax_grammars(self, **kwargs):  # noqa: E501
        """Get offline grammars' name  # noqa: E501

         Get all offline grammars' name. Please note, the default offline grammar's name is \"default\". Default offline grammar cannot be added, deleted or modified.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_offline_syntax_grammars(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: VoiceGetOfflineSyntaxGrammarsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_voice_offline_syntax_grammars_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_voice_offline_syntax_grammars_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_voice_offline_syntax_grammars_with_http_info(self, **kwargs):  # noqa: E501
        """Get offline grammars' name  # noqa: E501

         Get all offline grammars' name. Please note, the default offline grammar's name is \"default\". Default offline grammar cannot be added, deleted or modified.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_offline_syntax_grammars_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: VoiceGetOfflineSyntaxGrammarsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_voice_offline_syntax_grammars" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/asr/offlinesyntax/grammars', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VoiceGetOfflineSyntaxGrammarsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_voice_tts(self, **kwargs):  # noqa: E501
        """Get specified or current working status  # noqa: E501

         If the input parameter has a timestamp, it means getting the specified text to speech status. If the input parameter has no timestamp, it means getting the current text to speech status.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_tts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: Timestamp, Unix standard time.
        :return: VoiceGetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_voice_tts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_voice_tts_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_voice_tts_with_http_info(self, **kwargs):  # noqa: E501
        """Get specified or current working status  # noqa: E501

         If the input parameter has a timestamp, it means getting the specified text to speech status. If the input parameter has no timestamp, it means getting the current text to speech status.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_voice_tts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: Timestamp, Unix standard time.
        :return: VoiceGetResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_voice_tts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/tts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VoiceGetResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_voice_offline_syntax(self, body, **kwargs):  # noqa: E501
        """Add a new offline grammar  # noqa: E501

         Create a new offline grammar. Please note, the default offline grammar's name is \"default\". Default offline grammar cannot be added, deleted or modified. The current offline speech recognition can support Chinese and English. But the English support is an experimental feature. All the field name and value should be written as <html><font color=\"red\">uppercase camel case format</font></html>. ``` {  \"grammar\": \"LocalCmd\",  \"slot\": [   {    \"name\": \"Pre\"   },   {    \"name\": \"Commands\"   }  ],  \"start\": \"LocalCmdStart\",  \"startinfo\": \"[<Pre>]<Commands>\",  \"rule\": [   {    \"name\": \"Pre\",    \"value\": \"IWantYou|Please|Start\"   },   {    \"name\": \"Commands\",    \"value\": \"Dancing\"   }  ] } ```  Please be very careful when you configure offline grammar. If the configuration is not matched the restrictions. Speech recognition may not work. The restrictions as below: - All grammar value cannot be duplicated; - All slot field cannot be duplicated; - All rule field cannot be NULL. Every rule name and value should be unique. Please pay special attention that <html><strong><font color=\"blue\">VOID</font></strong></html>, <html><strong><font color=\"blue\">NULL</font></strong></html> and <html><strong><font color=\"blue\">GARBAGE</font></strong></html> are reserved as key words. Please do not use them. - In rule field, the user can use key words !id to define the semantic. The semantic only support numbers, please do not use other character. The supported semantic number is 32 bits signed integer. The range is <html>[-2<sup>(32-1)</sup>, 2<sup>(32-1)</sup> -1]</html>.  The grammar specification and built-in keywords:  | Operator | description | example | |---|---|---| |!| the next field is a keywords | !grammar| |<>| define a rule name | &lt;name&gt;| |;| terminator | end of a line | | &Iota; | Or, define a side-by-side structure | 张三&Iota;李四 | |[]| optional, indicating that the content can be said | &lt;call&gt;: [找] &lt;name&gt;| |:| define a rule | &lt;name&gt;:张三&Iota;李四| |()| encapsulation operation, defining implicit rules |&lt;call&gt;:找(张三&Iota;李四)| |/* */| block comment |/* comment content */| |//| line comment | // comment content | More details： https://doc.xfyun.cn/msc_windows/%E8%AF%AD%E6%B3%95%EF%BC%88%E5%91%BD%E4%BB%A4%E8%AF%8D%EF%BC%89%E8%AF%86%E5%88%AB.html   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_voice_offline_syntax(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoicePostOfflineSyntax body:  (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_voice_offline_syntax_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_voice_offline_syntax_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_voice_offline_syntax_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add a new offline grammar  # noqa: E501

         Create a new offline grammar. Please note, the default offline grammar's name is \"default\". Default offline grammar cannot be added, deleted or modified. The current offline speech recognition can support Chinese and English. But the English support is an experimental feature. All the field name and value should be written as <html><font color=\"red\">uppercase camel case format</font></html>. ``` {  \"grammar\": \"LocalCmd\",  \"slot\": [   {    \"name\": \"Pre\"   },   {    \"name\": \"Commands\"   }  ],  \"start\": \"LocalCmdStart\",  \"startinfo\": \"[<Pre>]<Commands>\",  \"rule\": [   {    \"name\": \"Pre\",    \"value\": \"IWantYou|Please|Start\"   },   {    \"name\": \"Commands\",    \"value\": \"Dancing\"   }  ] } ```  Please be very careful when you configure offline grammar. If the configuration is not matched the restrictions. Speech recognition may not work. The restrictions as below: - All grammar value cannot be duplicated; - All slot field cannot be duplicated; - All rule field cannot be NULL. Every rule name and value should be unique. Please pay special attention that <html><strong><font color=\"blue\">VOID</font></strong></html>, <html><strong><font color=\"blue\">NULL</font></strong></html> and <html><strong><font color=\"blue\">GARBAGE</font></strong></html> are reserved as key words. Please do not use them. - In rule field, the user can use key words !id to define the semantic. The semantic only support numbers, please do not use other character. The supported semantic number is 32 bits signed integer. The range is <html>[-2<sup>(32-1)</sup>, 2<sup>(32-1)</sup> -1]</html>.  The grammar specification and built-in keywords:  | Operator | description | example | |---|---|---| |!| the next field is a keywords | !grammar| |<>| define a rule name | &lt;name&gt;| |;| terminator | end of a line | | &Iota; | Or, define a side-by-side structure | 张三&Iota;李四 | |[]| optional, indicating that the content can be said | &lt;call&gt;: [找] &lt;name&gt;| |:| define a rule | &lt;name&gt;:张三&Iota;李四| |()| encapsulation operation, defining implicit rules |&lt;call&gt;:找(张三&Iota;李四)| |/* */| block comment |/* comment content */| |//| line comment | // comment content | More details： https://doc.xfyun.cn/msc_windows/%E8%AF%AD%E6%B3%95%EF%BC%88%E5%91%BD%E4%BB%A4%E8%AF%8D%EF%BC%89%E8%AF%86%E5%88%AB.html   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_voice_offline_syntax_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoicePostOfflineSyntax body:  (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_voice_offline_syntax" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_voice_offline_syntax`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/asr/offlinesyntax', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_voice_asr(self, body, **kwargs):  # noqa: E501
        """Start automatic speech recognition  # noqa: E501

         Please note, automatic speech recognition(asr) cannot work with auto transform(iat). When you start automatic speech, please make sure auto transform(iat) is not started.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_voice_asr(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceAsrOption body: (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_voice_asr_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_voice_asr_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def put_voice_asr_with_http_info(self, body, **kwargs):  # noqa: E501
        """Start automatic speech recognition  # noqa: E501

         Please note, automatic speech recognition(asr) cannot work with auto transform(iat). When you start automatic speech, please make sure auto transform(iat) is not started.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_voice_asr_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceAsrOption body: (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_voice_asr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_voice_asr`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/asr', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_voice_iat(self, **kwargs):  # noqa: E501
        """Start auto transform  # noqa: E501

         Please note, automatic speech recognition(asr) cannot work with auto transform(iat). When you start automatic speech, please make sure automatic speech recognition(asr) is not started.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_voice_iat(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceIatRequest body: 
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_voice_iat_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.put_voice_iat_with_http_info(**kwargs)  # noqa: E501
            return data

    def put_voice_iat_with_http_info(self, **kwargs):  # noqa: E501
        """Start auto transform  # noqa: E501

         Please note, automatic speech recognition(asr) cannot work with auto transform(iat). When you start automatic speech, please make sure automatic speech recognition(asr) is not started.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_voice_iat_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceIatRequest body: 
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_voice_iat" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/iat', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_voice_offline_syntax(self, body, **kwargs):  # noqa: E501
        """Update offline grammar based grammar's name  # noqa: E501

         Update an offline grammar based the grammar name. Please note, the default offline grammar's name is \"default\". Default offline grammar cannot be added, deleted or modified. The current offline speech recognition can support Chinese and English. But the English support is an experimental feature. All the field name and value should be written as <html><font color=\"red\">uppercase camel case format</font></html>. ``` {  \"grammar\": \"LocalCmd\",  \"slot\": [   {    \"name\": \"Pre\"   },   {    \"name\": \"Commands\"   }  ],  \"start\": \"LocalCmdStart\",  \"startinfo\": \"[<Pre>]<Commands>\",  \"rule\": [   {    \"name\": \"Pre\",    \"value\": \"IWantYou|Please|Start\"   },   {    \"name\": \"Commands\",    \"value\": \"Dancing\"   }  ] } ```  Please be very careful when you configure offline grammar. If the configuration is not matched the restrictions. Speech recognition may not work. The restrictions as below: - All grammar value cannot be duplicated; - All slot field cannot be duplicated; - All rule field cannot be NULL. Every rule name and value should be unique. Please pay special attention that <html><strong><font color=\"blue\">VOID</font></strong></html>, <html><strong><font color=\"blue\">NULL</font></strong></html> and <html><strong><font color=\"blue\">GARBAGE</font></strong></html> are reserved as key words. Please do not use them. - In rule field, the user can use key words !id to define the semantic. The semantic only support numbers, please do not use other character. The supported semantic number is 32 bits signed integer. The range is <html>[-2<sup>(32-1)</sup>, 2<sup>(32-1)</sup> -1]</html>.  The grammar specification and built-in keywords:  | Operator | description | example | |---|---|---| |!| the next field is a keywords | !grammar| |<>| define a rule name | &lt;name&gt;| |;| terminator | end of a line | | &Iota; | Or, define a side-by-side structure | 张三&Iota;李四 | |[]| optional, indicating that the content can be said | &lt;call&gt;: [找] &lt;name&gt;| |:| define a rule | &lt;name&gt;:张三&Iota;李四| |()| encapsulation operation, defining implicit rules |&lt;call&gt;:找(张三&Iota;李四)| |/* */| block comment |/* comment content */| |//| line comment | // comment content | More details： https://doc.xfyun.cn/msc_windows/%E8%AF%AD%E6%B3%95%EF%BC%88%E5%91%BD%E4%BB%A4%E8%AF%8D%EF%BC%89%E8%AF%86%E5%88%AB.html   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_voice_offline_syntax(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoicePutOfflineSyntax body:  (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_voice_offline_syntax_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_voice_offline_syntax_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def put_voice_offline_syntax_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update offline grammar based grammar's name  # noqa: E501

         Update an offline grammar based the grammar name. Please note, the default offline grammar's name is \"default\". Default offline grammar cannot be added, deleted or modified. The current offline speech recognition can support Chinese and English. But the English support is an experimental feature. All the field name and value should be written as <html><font color=\"red\">uppercase camel case format</font></html>. ``` {  \"grammar\": \"LocalCmd\",  \"slot\": [   {    \"name\": \"Pre\"   },   {    \"name\": \"Commands\"   }  ],  \"start\": \"LocalCmdStart\",  \"startinfo\": \"[<Pre>]<Commands>\",  \"rule\": [   {    \"name\": \"Pre\",    \"value\": \"IWantYou|Please|Start\"   },   {    \"name\": \"Commands\",    \"value\": \"Dancing\"   }  ] } ```  Please be very careful when you configure offline grammar. If the configuration is not matched the restrictions. Speech recognition may not work. The restrictions as below: - All grammar value cannot be duplicated; - All slot field cannot be duplicated; - All rule field cannot be NULL. Every rule name and value should be unique. Please pay special attention that <html><strong><font color=\"blue\">VOID</font></strong></html>, <html><strong><font color=\"blue\">NULL</font></strong></html> and <html><strong><font color=\"blue\">GARBAGE</font></strong></html> are reserved as key words. Please do not use them. - In rule field, the user can use key words !id to define the semantic. The semantic only support numbers, please do not use other character. The supported semantic number is 32 bits signed integer. The range is <html>[-2<sup>(32-1)</sup>, 2<sup>(32-1)</sup> -1]</html>.  The grammar specification and built-in keywords:  | Operator | description | example | |---|---|---| |!| the next field is a keywords | !grammar| |<>| define a rule name | &lt;name&gt;| |;| terminator | end of a line | | &Iota; | Or, define a side-by-side structure | 张三&Iota;李四 | |[]| optional, indicating that the content can be said | &lt;call&gt;: [找] &lt;name&gt;| |:| define a rule | &lt;name&gt;:张三&Iota;李四| |()| encapsulation operation, defining implicit rules |&lt;call&gt;:找(张三&Iota;李四)| |/* */| block comment |/* comment content */| |//| line comment | // comment content | More details： https://doc.xfyun.cn/msc_windows/%E8%AF%AD%E6%B3%95%EF%BC%88%E5%91%BD%E4%BB%A4%E8%AF%8D%EF%BC%89%E8%AF%86%E5%88%AB.html   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_voice_offline_syntax_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoicePutOfflineSyntax body:  (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_voice_offline_syntax" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_voice_offline_syntax`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/asr/offlinesyntax', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_voice_tts(self, body, **kwargs):  # noqa: E501
        """Start text to speech  # noqa: E501

         Start text to speech and play the result.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_voice_tts(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceTTSStr body: (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_voice_tts_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.put_voice_tts_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def put_voice_tts_with_http_info(self, body, **kwargs):  # noqa: E501
        """Start text to speech  # noqa: E501

         Start text to speech and play the result.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_voice_tts_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param VoiceTTSStr body: (required)
        :return: CommonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_voice_tts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_voice_tts`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/voice/tts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommonResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
